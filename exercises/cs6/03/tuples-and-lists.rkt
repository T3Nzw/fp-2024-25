#lang racket

; Наредени двойки:
;-----------------
; cons създава наредена 2-ка
(cons 1 #\a) ; (1 . #\a)
; Тук точката индикира че това е наредена 2-ка.
; В R5RS се принтира префиксно като mcons.

(define some-pair (cons "first" "second"))

; Функции с които достъпваме елементите на наредена двойка:

; - Първия елемент (Contents of the Address Register)
(car some-pair)   ; "hello"

; - Втория елемент (Contents of the Data Register)
(cdr some-pair)   ; "world"


; Списъци:
;---------
; 1. '() е списък
; 2. '(head . tail) е списък <=> tail е списък

(list 1 2 3 4) ; построява списък от подадените аргументи

; Ясно се вижда че списъците са наредени 2ки,
; но наредените 2ки не винаги са списъци.
(cons 1 (cons 2 (cons 3 (cons 4 5))))  ; '(1 2 3 4 . 5)
(cons 1 (cons 2 (cons 3 (cons 4 '())))) ; '(1 2 3 4)

(pair? '()) ; #f
(list? '()) ; #t
(null? '()) ; #t
; NOTE: Има символ null в racket (но НЕ в R5RS),
;       който е свързан точно с '()

; Списък може да се конструира и с quote
(quote (1 2 3 4))

; Но обикновено се използва съкратен синтаксис:
'(1 2 3 4)

; Q: Каква е разликата дали ползваме list или quote?

; quote е специална форма и не оценява аргументите си,
; а се прилага "рекурсивно" върху тях
'(1 2 3)
; е същото като
(list '1 '2 '3)

; quote не оценява символите, а ги взима буквално
'(+ 1 2)  ; тук '+ ще бъде само символ (immutable string)

; Ако на мястото на някой елемент сложим променлива,
; то quote ще вземе буквално името й като символ,
; а list ще я оцени
(list + 1 2)  ; тук + ще бъде процедура

; Q: За какво са ни тези неоценени символи?

; Понеже quote се изпълнява рекурсивно,
; е по-лесно да правим дълбоки списъци
(define deep-list '( (1 2)
                     ((3 4) 5)
                     6
                     (7)))

; Има съкратен синтаксис за композиция на car и cdr:
; caar - първия елемент на първия елемент
; cdar - втория елемент на първия елемент
; и т.н. до общо 4 срещания на "a" и "d"

(caar deep-list)  ; 1
(cdar deep-list)  ; (2)
; На практика се изпълняват отзад напред


; Side Note - Сравнения:
;-----------------------
; (= a b) работи само за числа

; (eq? a b) проверява дали a и b са един и същ обект
; (на едно и също място в паметта)

; (eqv? a b) е като eq? с изключение за някои типове
; на аргументите - като char и integer

; (equal? a b) e като eqv? с изключение за много типове.
; Работи за списъци и може да сравнява покомпонентно.


;===============;=========================================
;; З А Д А Ч И ;;
;;;;;;;;;;;;;;;;;

; Решете БЕЗ да използвате вложени дефиниции!

; NOTE: Суфикса * е защото съществуват вградени процедури
;       със същите имена в racket

; Дефиницията на списък:
; 1. '() е списък
; 2. '(head . tail) е списък <=> tail е списък

; 0. Намира дължина на списък
; Пример: (length* '(1 2 3 4)) ~> 4
(define (length* lst) 'undefined)

; 1. Връща списък от първите n елемента
; Пример: (take* 2 '(0 1 2 3)) ~> '(0 1)
; Пример: (take* -5 '(0 1 2 3)) ~> '()
; Пример: (take* 10 '(0 1 2 3)) ~> '(0 1 2 3)
(define (take* n lst) 'undefined)

; 2. Връща списък като lst, но без първите n елемента
; Пример: (drop* 2 '(0 1 2 3)) ~> '(2 3)
; Пример: (drop* -5 '(0 1 2 3)) ~> '(0 1 2 3)
; Пример: (drop* 10 '(0 1 2 3)) ~> '()
(define (drop* n lst) 'undefined)

; 3. Генерира списък от целите числа в интервала [a,b]
; Пример: (from-to -2 2) ~> '(-2 -1 0 1 2)
; Пример: (from-to 0 -5) ~> '()
(define (from-to a b) 'undefined)

; 4. По даден списък от числа - намира сумата им.
; Пример: (sum '(1 2 3 4)) ~> 10
(define (sum lst) 'undefined)

; 5. Връща последния елемент на непразния списък lst.
; Пример: (last* '(1 2 3 4)) ~> 4
(define (last* lst) 'undefined)

; 6. Връща n-тия елемент на списъка lst, където n е естествено число.
; Пример: (nth 2 '(1 2 3 4)) ~> 3
; Пример: (nth 9 '(1 2 3 4)) ~> грешка!
(define (nth n lst) 'undefined)

; 7. Залепя l1 и l2 в списък от наредени 2ки.
; Може списъците да са с различна дължина.
; Пример: (zip '(1 2 3) '(4 5)) -> '((1 . 4) (2 . 5))
(define (zip l1 l2) 'undefined)

; 8. Връща конкатенацията на lst1 и lst2.
; Пример: (append* '(1 2 3) '(4 5)) -> '(1 2 3 4 5)
(define (append* lst1 lst2) 'undefined)

; 9. Връща lst след прилагане на f върху всеки елемент.
; Пример: (map* (lambda (x) (expt x 2)) '(1 2 3 4)) ~> '(1 4 9 16)
; Пример: (map* even '(1 2 3 4)) ~> '(#false #true #false #true)
(define (map* f lst) 'undefined)

; 10. Връща списък от елементите на lst, за които предиката p е верен
; Пример: (filter* even? '(1 2 3 4 5 6)) ~> '(2 4 6)
; Пример: (filter* odd? '(2 4 6)) ~> '()
(define (filter* p lst) 'undefined)

; TODO: Дай обяснение на долните функции

; 11. Като функцията accumulate, но за списъци
; Пример: (foldl* - 0 '(1 2 3 4)) -> -10
(define (foldl* op acc lst) 'undefined)

; 12. Като foldl, но рекурсивно
; Забележка: Началната стойност е десният аргумент на операцията
; Пример: (foldr* - 0 '(1 2 3 4)) -> -2
(define (foldr* op acc lst) 'undefined)
