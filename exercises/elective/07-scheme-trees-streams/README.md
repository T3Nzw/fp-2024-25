# 07. Дървета, асоциативни списъци и потоци


## Двоични дървета

1. Основни конструкции: `(make-tree root left right)`, `(root-tree tree)`, `(left-tree tree)`,
   `(right-tree tree)`, `(empty-tree? tree)`, `(leaf-tree? tree)`, `(tree? x)`

2. Обхождане: `(pre-order t)`, `(in-order t)` и `(post-order t)`, които връща списък от елементите на дървото, обходено съотвено `корен-ляво-дясно`, `ляво-корен-дясно` и `ляво-дясно-корен`.

3. Напишете функция `(map-tree f t)`, която заменя всеки връх `x` от дървото `t` с `(f x)`.

4. Напишете функция `(height t)`, която намира височината на дървото `t`. Това е броят на върховете в най-дългия път.

5. Напишете функция `(level n t)`, която връща списък с всички върхове от дървото с дълбочина `n`.
> Дълбочината на корена е 0.

6. Напишете функция `(count-leaves t)`, която връща броя листа на t.
> Листо е връх от дърво, който няма наследници.

7. Напишете функция `(remove-leaves t)`, която връща дървото t, премахвайки листата му.

8. Напишете функция `(invert t)`, която разменя левите поддървета на `t` с десните.

9. Напишете функция `(bst? t)`, която намира дали `t` е двоично **наредено** дърво.

10. Напишете функция `(insert-bst x t)`, която добавя елемент `x` в двоично **наредено** дърво `t`, запазвайки наредбата му.

11. Дадено двоично дърво е балансирано, ако:
   1. е празното двоично дърво или
   2. височините на лявото и дясното поддърво се различават най-много с 1 и лявото и дясното поддървета са балансирани.

   Напишете предикат `(balanced? tree)`, която проверява дали дървото `tree` е балансирано.


## Асоциативни списъци

1. Напишете функция `(enumerate l)`, която връща асоциативен списък, в който всеки елемент `x` на `l` е асоцииран с ключ, равен на позицията на `x` в `l`.

2. Напишете функция `(histogram l)`, която
   връща хистограма на срещанията на всички елементи в `l` под формата на асоциативен списък.

   ```scheme
   (histogram '(8 7 1 7 8 2 2 8 2 7 8 1)) ;; => '((8 . 4) (7 . 3) (1 . 2) (2 . 3))
   ```

3. Напишете функция, която в асоциативен списък изчиства дублирани ключове, като запазва само първата стойност.

4. Напишете функция, която слива два асоциативни списъка, като за общите ключове прилага двуместна операция подадена като аргумент.

5. Напишете функция `(group-by f l)`, която връща асоциативен списък, в който ключовете са стойностите на функцията `f` след прилагането ѝ върху елементи от списъка `l`, а срещу ключовете стои списък от елементите, за които функцията `f` дава стойността от ключа.

```scheme
(group-by (lambda (x) (remainder x 3)) '(0 1 2 3 4 5 6 7 8)) ;; => '((0 0 3 6) (1 1 4 7) (2 2 5 8))
```

6. Напишете функция `(run-length-encode l)`, която кодира списъка `l` в асоциативен списък - списък от наредени двойки `'(<ключ> . <стойност>)`, където `<ключ>`-ът e пореден елемент от списъка `l`, а `<стойност>`-та е колко пъти се повтаря елемента последователно.

```scheme
(run-length-encode '(8 7 7 2 2 2 2 3 3 2)) ;; => '((8 . 1) (7 . 2) (2 . 4) (3 . 2) (2 . 1))
```

7.  Напишете функция `(run-length-decode code)`, която възстановява списъка, който е кодиран чрез `run-length-encode` от предната задача в асоциативния списък `code`.

```scheme
(run-length-decode '((1 . 2) (3 . 4) (5 . 2))) ;; => '(1 1 3 3 3 3 5 5)
```


## Потоци

Под "потоци" разбираме структури от данни, които представят безкраен генератор на елементи.

За да имплементираме потоци, ни трябва концепция за лениво оценяване, която в scheme имплементираме чрез следните основни функции/макрота:

- `(delay <израз>)` - връща promise обект, който кодира изчислението на `<израз>` в себе си
- `(force x)` - взима `promise` обекта x и връща резултата от изчислението, кодирано в него

Имайки този механизъм, можем да имплементираме потоци:

- `(stream-cons fst rst)` - създава поток с глава - резултата от израза `fst` и опашка - потокът, резултат от израза `rst`
- `(stream-first s)` - връща първия елемент на потока `s`
- `(stream-rest s)` - връща потока `s` без първия му елемент

1. Дефинирайте функцията `(iterate f x)`, която по дадена функция `f` връща безкрайния поток `x`, `f(x)`, `f(f(x))`, ...

2. Дефинирайте константата `nats`, която е поток от всички естествени числа

3. Дефинирайте функцията `(stream-take s n)` която връща списък (не поток!) от първите n елемента на потока s.

4. Дефинирайте функцията `(stream-map f s)`, която връща поток от резултатите от прилагане на `f` върху елементите на потока `s`.

5. Дефинирайте функцията `(stream-filter p s)`, която връща поток, подобен на s, но само с елементите, за които е изпълнен предиката `p`

6. Използвайки резултатите от предните задачи, дефинирайте константата `primes`, която е поток от всички прости числа

7. Дефинирайте константата `primes_erathostenes`, която е поток от всички прости числа, и е имплементирана чрез безкрайно сито на Ератостен.
