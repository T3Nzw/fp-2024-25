# 08. Въведение в Haskell

## Типове

> [!NOTE]
> **Винаги** главна буква

### Основни

- `Bool`

```haskell
True -- #t
False -- #f
```

- `Char`

```haskell
'a' 'b' 'c'
```

- `String`

```haskell
"This is a string"
```

- `Int` - цяло число

```haskell
[-2^29 .. 2^29-1]
```

- `Integer` - цяло число с неограничен размер (като числата в scheme)

```haskell
2^29
```

- `Float`, `Double`

```haskell
1.2 0.5
```

### Типове на функции

- `Int -> Char`
- `Int -> Int -> Int`
- `(Int -> Int) -> (Int -> Int)`

## Типови параметри, параметрични типове

- `a`, `b`, `a -> b`, `(a -> b) -> a -> b`

> [!NOTE]
> **Винаги** малка буква


## Функция VS Оператор

В Haskell има значение от името на една функция дали тя ще е "просто функция" или оператор. Наричаме (не само ние, Haskell също) една функция "оператор" ако името ѝ се състои само от символи (без букви)

```haskell
a +-//^ b = a + b
1 +-//^ 3 -- 8
```

Ако пък името ѝ се състои само от букви (+ долни черти, единични кавички и т.н...), то тогава тя е нормална префиксна функция

```haskell
foo_123_'' x y = x + y
foo_123_'' 5 1 -- 6
```
Haskell обаче ни позволява да ползваме функция "все едно е оператор", както и оператор "все едно е функция". Това става по следният начин:

  - Слагането на ` около името на функция я "кара да се превърне в оператор"
  ```haskell
  f a b = a + b -- функция

  f 1 2 -- 3
  1 `f` 2 -- 3
  ```

  - Слагането на скоби около оператор го "кара да се превърне във (нормална) функция"
  ```haskell
  (+) 1 2 -- 3
  ```

  - Затова при декларираме оператори ползваме този синтаксис
  ```haskell
  (+-//^) :: Int -> Int -> Int
  a +-//^ b = a + b
  ```

## Curry

Нека имаме:

```haskell
f :: Int -> Int -> (Int -> Int) -> Int
f a b c = c (a + b)
```

Можем да мислим за `->` като за оператор, но който работи върху типове, а не данни. Този "оператор" е дясно-асоциативен. Това означава, че `f :: Int -> Int -> (Int -> Int) -> Int` е същото като `f :: (Int -> (Int -> ((Int -> Int) -> Int)))`. Т.е. реално, когато викаме "функция с няколко аргумента", ние просто подаваме един по един аргументите на функцията, върната от последното даване на един аргумент.

## Отсичане

Доста често ни се налага да пишем функции, подобни на тези:

```haskell
\x -> x + 1
\x -> 5 * x
```

Haskell ни позволява да "отсечем" един от аргументите на извикване на опратор, което има същата семантика като да имаме "дупка"/аргумент на мястото на изтритото:

```haskell
f x = x + 1
f = \x -> x + 1
f = (+1)

g x = x * 5
g = \x -> x * 5
g = (*5)

map (+1) [1, 2, 3] -- [2, 3, 4]
```

> [!NOTE]
> Отсичането може да се случи както за левия, така и за десния аргумент

## Основни конструкции

- Константа:

```haskell
foo :: Int
foo = 42
```

- Функция:

```haskell
add :: Int -> Int -> Int
add x y = x + y
```

- `if`

```haskell
if <condition> then <true_expression> else <false_expression>
```

- guards (`cond`)

```haskell
f :: Int -> Integer
f x
  | x < 0     = error "x must be positive"
  | x == 0    = 1
  | otherwise = x * f (x - 1)
```

- Шаблони (pattern-matching)

А ако знаем точни с какви стойности ще работим - можем дирекно да си дефинираме функцията за тях (вместо да им даваме име `x` и да проверяваме факти за него):

```haskell
f :: Int -> Integer
f 0 = 0
f 1 = 1
f n = f (n - 1) + f (n - 2)
```

Тук `0`, `1` и `n` са т.нар. **шаблони**, може да си мислим за тях като "част" от стойност (включително никаква или пълна част). `1` е шаблон за числа, който би "match"-нал само единици. `_` е специален шаблон, който match-ва всичко.

> [!NOTE]
> Шаблоните са изключително полезни, когато работим със съставни типове от данни като списъци или дървета.


## Задачи

Имплементирайте следните функции:

### Без рекурсия:

1. `myAbs n` изчислява модул от `n`

2. `isTriangle a b c`, която връща дали числата `a`, `b` и `c` образуват валиден триъгълник

3. `countDays day month year`, която приема ден, месец и година и връща броя на дните от началото на годината до съответния ден.

### Рекурсивни функции:

4. `isPrime n`, която връща дали числото `n` е просто.

5. `sumDivisors n`, която връща сбора на собствените делители на числото `n`.

6. `isPerfect n`, която връща дали `n` е съвършено число

7. `countBinaryDigits n`, която връща броя на цифрите в двоичната репрезентация на `n`.

8. `isEvil n`, която връща дали числото `n` е зло ("evil"). Наричаме едно число зло ако броя на битовете, които са `1` е четен.

9. `sumEvil a b`, която връща сбора на злите числа в интервала `[a .. b]`

10. **Бонус**:  `compose f g x`, която връща композицията на две едноместни функции `f` и `g` (Какъв е типа на `compose`)

