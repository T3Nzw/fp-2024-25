# Упражнение 3

# Малко теория

## Локални дефиниции (`let`, `let*`)
Конструкции, които ни позволяват да свържем име и стойност локално за израза.

- `let` прави паралелно (едновременно) свързване;
- `let*` прави последователно свързване, т.е. можем да ползваме по-горните дефиниции в тези след тях;

```scheme
(define (sum-digits n)
  (if (= n 0)
      0
      (let ([last-digit (remainder n 10)]
            [prev-digits (quotient n 10)])
        (+ last-digit (sum-digits prev-digits)))))

(define (f x)
  (let* ([a (+ 1 x)]
         [b (* 2 a)]
         [c (+ a b)])
    (list a b c)))
```

## Lambda функции

Анонимни фукнции - удобни когато фукнцията, която дефинираме, се използва само на едно място. Не е нужно да им измисляме име.

```scheme
(lambda (arg1 arg2 ... argn)
    body)

;; идентитет
(define id
  (lambda (a) a))

;; функция, която при подадено число, връща следващото
(define (++ a)
  (+ a 1))

;; всъщност е същото като
(define ++
  (lambda (a) (+ a 1)))

;; lambda функциите могат да бъдат извикани с аргументи веднага след дефиницията си
> ((lambda (x) (* x x)) 3) ;; => 9
```

## Функции от по-висок ред

Функциите в Scheme са "first-class" обекти - т.е. можем да боравим с тях, както с всички останали стойности (числа, списъци). Функция от по-висок ред е тази, която приема функция като аргумент и/или връща функция като резултат.

```scheme
;; функция, която приема и връща функция като резултат
(define (apply2 func)
  (lambda (a b)
    (func a b)))

(apply2 + 1 2) ;; => error
;; apply2: arity mismatch;
;; the expected number of arguments does not match the given number
;; expected: 1
;; given: 3

((apply2 +) 1 2) ;; => 3
((apply2 expt) 2 3) ;; => 8
((apply2 string-append) "Scheme " "rocks!") ;; => "Scheme rocks!"
```

И, разбира се, познатият ни `accumulate` от лекции:

```scheme
(define (accumulate op nv a b term next)
  (if (> a b)
      nv
      (op (term a) (accumulate op nv (next a) b term next))))


(define (accumulate-i op nv a b term next)
  (if (> a b)
      nv
      (accumulate-i op (op nv (term a)) (next a) b term next)))
```

# Задачи

## Функции от по-висок ред

Дефинирайте следните функции:

1. `(compose f g)`, която връща композицията на `f` и `g`, т.е. `((compose f g) x)` е еквивалентно на `(f (g x))`
2. `(const c)`, която приема константа `c` и връща функция, чиято стойност винаги е `c`.
3. `(fmax f g)`, която приема две едноаргументни числови функции `f` и `g` и връща функция, чиято стойност в дадена точка `x` е по-голямата от стойностите на `f` и `g` в `x`.
4. `(repeated n f x)`, която връща `f`, приложена `n` пъти върху `x`
5. `(repeat n f)`, която връща функция, чието действие има семантика на прилагане на `f` `n` пъти

## Accumulate

Напишете следните функции, използвайки `accumulate` или `accumulate-i`. Във всеки от случаите, нека `p?` е произволна дадена функция (предикат), която връща `#t` или `#f` при подадено число:

6. `(count p? a b)`, която връща брой числа `i` от интервала `[a, b]`, за които `(p? i) --> #t`
7. Предикат `(any? p? a b)`, който проверява дали `p` връща истина за поне едно цяло число от интервала `[a, b]`
8. Предикат `(all? p? a b)`, който проверява дали `p` връща истина за всяко цяло число от интервала `[a, b]`
9. Функциите `repeated` и `repeat` от предния раздел
