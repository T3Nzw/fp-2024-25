# Графи, асоциативни списъци, мутиращи операции и потоци

```racket
(define our-cool-graph '((1 . (2 3))
                         (2 . (3))
                         (3 . (4 5))
                         (4 . ())
                         (5 . (2 4 6))
                         (6 . (2))))
```

### Задача 1
Реализирайте процедура, която връща списък от точкови двойки от видя `'(u . v)`, показващи, че има ребро от `u` до `v`.

```racket
(equal? (edges our-cool-graph) '((1 . 2) (1 . 3) (2 . 3) (3 . 4) (3 . 5) (5 . 2) (5 . 4) (5 . 6) (6 . 2)))
```

### Задача 2
Реализирайте процедура, която приема унарен предикат `pred?` и връх `v` и връща списък от децата на `v`, които удовлетворяват този предикат.

```racket
(equal? (filter-children our-cool-graph even? 3) '(4))
```

### Задача 3
Реализирайте процедура, която премахва връх `v` от граф.

```racket
(equal? (remove-vertex 5 our-cool-graph) '((1 2 3)
                                          (2 3)
                                          (3 4)
                                          (4)
                                          (6 2)))
```

### Задача 4
Реализирайте процедура, която проверява дали има път от `u`до `v` в граф.

```racket
(equal? (path? 1 6 our-cool-graph) #t)
(equal? (path? 5 1 our-cool-graph) #f)
```

### Задача 5
Реализирайте процедури, които обхождат граф в дълбочина и в широчина. Напишете подходящи тестове.

### Задача 6
Реализиайте процедура, която връща първата дадена стойност по подаден ключ в асоциативен списък. Ако такъв ключ няма, да се върне `#f`.

 - чрез рекурсия
 - чрез функции от по-висок ред
 - чрез `assoc`

```racket
(equal? (assoc-rec 1 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) "One")
(equal? (assoc-rec 4 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) #f)

(equal? (assoc-hop 1 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) "One")
(equal? (assoc-hop 4 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) #f)

(equal? (assoc-assoc 1 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) "One")
(equal? (assoc-assoc 4 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) #f)
```

### Задача 7
Реализирайте процедура, която по подаден ключ изтрива първата съответстваща двойка със същия ключ в асоциативен списък. Ако няма такъв ключ, да се върне същия списък.

```racket
(equal? (assoc-del 1 (list '(2 . "Two") '(3 . "Three") '(1 . "One"))) '((2 . "Two") (3 . "Three")))
(equal? (assoc-del 1 (list '(2 . "Two") '(3 . "Three"))) '((2 . "Two") (3 . "Three")))
```

### Задача 8
Реализирайте процедура `(replace xs dict)`, която заменя елементите в `xs`, които са ключове в `dict` със съответните им стойности в `dict`.

```racket
(equal? (replace '(1 2 3 4) '((1 . 11) (2 . 22))) '(11 22 3 4))
```

### Задача 9
Реализирайте процедура `make-f-alist`, която приема списък `xs` и унарна процедура `f`, която създава асоциативен списък с елементи от вида `(x . f(x))`.

```racket
(equal? (make-f-alist '(1 2 3) add1) '((1 . 2) (2 . 3) (3 . 4)))
```

### Задача 10
Реализирайте процедури `assoc-keys` и `assoc-values`, които приемат асоциативен списък и връщат съответно списък от ключовете и списък от стойностите.

```racket
(equal? (assoc-keys '((1 . "One") (2 . "Two") (3 . "Three"))) '(1 2 3))
(equal? (assoc-keys '()) '())

(equal? (assoc-values '((1 . "One") (2 . "Two") (3 . "Three"))) '("One" "Two" "Three"))
(equal? (assoc-values '()) '())
```

### Задача 11
Реализиайте процедура, която чете единствен ред от стандартния вход, разделя го на отделни елементи относно символа ' ' и ги запазва в списък.

### Задача 12 :mirror:
Реализирайте програма, която отпечатва собствения си source code.

### Задача 13 :framed_picture:
След поредния невзет изпит Радо сериозно започва да се замисля дали ФМИ е за него... Вътрешно той знае за себе си, че не е роден да става програмист, а че неговото призвание е изкуството. Радо е голям почитател на обработването на изображения - да отрязва конкретни части от тях, да ги преоразмерява, да добавя ефекти и т.н. Покажете на Радо, че може да съчетава изкуството с програмирането, като му помогнете да си напише собствена програма, която прави един простичък, но полезен ефект - превръща цветни изображения в черно-бели такива. (*за да звучи по-fancy - от RGB в Grayscale*).

Тошко - най-добрият приятел на Радо, му подсказал, че най-лесно би постигнал това, като обработва `bmp` изображения. Той му обяснил, че това всъщност не са нищо повече от обикновени двоични файлове. Като един истински приятел, Тошко дори разяснил в подробности какви са особеностите на `bmp` изображенията:
- Състоят се от **две** основни части - служебна информация за изображението (**метаданни**) и матрица от пиксели (**практическото съдържание на изображението**)
- Не ни е необходима цялата информация от метаданните; трябват ни само:
    - размерът на файла (**позиция 2**, *4 байта*)
    - позицията, на която започва матрицата от пиксели (**позиция 10**, *4 байта*)
    - брой колони на матрицата от пиксели (**позиция 18**, *4 байта*)
    - брой редове на матрицата от пиксели (**позиция 22**, *4 байта*)
- Всеки пиксел се състои от *3 байта*, по един за всеки от основните три цвята - червено, зелено и синьо (**RGB**) (стойности между **0** и **255**)
- Всеки ред има **padding**, допълващ броя на байтовете на всеки ред да бъде число, делящо се на **4**
- Информацията в padding-a се игнорира при визуализиране на изображението

За да превърне RGB пиксел в Grayscale такъв, Радо попитал своята приятелка Габи, която е специалистка в алгоритмите. За да покаже колко много знае, тя му дала списък със 100 различни алгоритми:
- `Grayscale Value = (R + G + B) / 3`
- `Grayscale Value = (max(R, G, B) + min(R, G, B)) / 2`
- `Grayscale Value = 0.2126 * R + 0.7152 * G + 0.0722 * B`
- `Grayscale Value = 0.30 * R + 0.59 * G + 0.11 * B`
- *списъкът продължава с още 96 алгоритъма...*

Тъй като алгоритмите практически постигат почти един и същи резултат, няма особено голямо значение кой от тях ще избере Радо.

За да бъдете от истинска помощ на Радо, приемете две имена на двоични файлове на изображения в `bmp` формат от командния ред - първият трябва да бъде на съществуващо цветно RGB изображение, а във втория трябва да бъде запазеното конвертираното Grayscale изображение. Използвайки информацията, предоставена ви от Тошко и Габи, реализирайте алгоритъма за конвертиране чрез подходящи процедури.

### Задача 14
Реализирайте процедура `stream-range`, която приема две числа `a` и `b` и генерира поток, състоящ се от всички числа в интервала `[a;b]`.

```racket
(equal? (stream-take 5 (stream-range 5 100)) '(5 6 7 8 9))
(equal? (stream-take 8 (stream-range 1 3)) '(1 2 3))
```

### Задача 15
Реализирайте процедура `natural-numbers`, която генерира безкраен поток от естествени числа.

```racket
(equal? (stream-take 5 natural-numbers) '(1 2 3 4 5))
(equal? (stream-take 8 natural-numbers) '(1 2 3 4 5 6 7 8))
```

### Задача 16
Реализирайте процедура `stream-map`, която приема унарна процедура `f` и поток и я прилага върху елементите на потока.

```racket
(equal? (stream-take 5 (stream-map (λ (x) (* x 2)) natural-numbers)) '(2 4 6 8 10))
(equal? (stream-take 8 (stream-map (λ (x) (* x 2)) natural-numbers)) '(2 4 6 8 10 12 14 16))
```

### Задача 17
Реализирайте процедура `stream-filter`, която приема унарен предикат `pred?` и поток и връща поток, състоят се само от елементите, удовлетворяваши предиката.

```racket
(equal? (stream-take 5 (stream-filter odd? natural-numbers)) '(1 3 5 7 9))
(equal? (stream-take 8 (stream-filter even? natural-numbers)) '(2 4 6 8 10 12 14 16))
```