# Списъци.

### Задача 1
Напишете процедура `sort-list`, която приема списък и връща ламбда, която приема бинарна процедура и сортира елементите според тази процедура. Например, ако искаме да сортираме масив от символни низове `'("one" "two" "0" "five" "" "one hundred" "onehundred")` според дължината на всеки низ, то резултатът трябва да бъде `'("" "0" "one" "two" "five" "onehundred" "one hundred")`. Напишете тест с този тестов случай.

### Задача 2
Напишете процедура, която намира дължината на списък.

```racket
(= (my-length '()) 0)
(= (my-length '(1 2 5 6 4 8)) 6)
```

### Задача 3
Напишете процедура, която намира най-малкия елемент в списък.

```racket
(= (get-smallest '(1 2 5)) 1)
(= (get-smallest '(2 1 5)) 1)
(= (get-smallest '(2 1 -1 5)) -1)
```


### Задача 4
Напишете процедура, която премахва първото срещане на елемент от списък. Напишете и такава, която премахва всички срещания на елемента в списъка.

```racket
(equal? (remove-first 1 '(1 1 1 2)) '(1 1 2))
(equal? (remove-first 1 '(2 5 6)) '(2 5 6))
(equal? (remove-first 1 '(1)) '())
(equal? (remove-first 1 '(2 1)) '(2))
(equal? (remove-first "RNN" '("CNN" "RNN" "GAN" "RNN")) '("CNN" "GAN" "RNN"))

(equal? (remove-all 1 '(1 1 1 2)) '(2))
(equal? (remove-all 1 '(2 5 6)) '(2 5 6))
(equal? (remove-all 1 '(1)) '())
(equal? (remove-all 1 '(1 2 1 1)) '(2))
(equal? (remove-all "RNN" '("CNN" "RNN" "GAN" "RNN")) '("CNN" "GAN"))
```

### Задача 5
Напишете процедура, която транформира число към списък от цифрите му. Напишете и обратната процедура.

```racket
(equal? (num-to-xs 123) '(1 2 3))
(equal? (num-to-xs 123456789) '(1 2 3 4 5 6 7 8 9))

(= (xs-to-num '(1 2 3)) 123)
(= (xs-to-num '(1 2 3 4 5 6 7 8 9)) 123456789)
```

### Задача 6
Напишете процедура, която приема две множества (представени чрез списъци) и връща тяхното обединение. То трябва да бъде сортирано в нарастващ ред.

```racket
(equal? (set-union '(1 3 5 7) '(5 7 13)) '(1 3 5 7 13))
(equal? (set-union '(5 7 13) '(1 3 5 7)) '(1 3 5 7 13))
```

### Задача 7
Обърнете списък, използвайки `foldl`.

```racket
(equal? (my-reverse-foldl '(1 2 3 4 5)) '(5 4 3 2 1))
```

### Задача 8
Дефинирайте процедура, която приема списък от числа и връща унарна процедура на число `k`, чийто резултат е `k`-тото най-голямо отрицателно число в списъка.

```racket
(= ((kth-max-negative '(-1)) 1) -1)
(= ((kth-max-negative '(-1 -5 -6 -6 -6 -6)) 2) -5)
(= ((kth-max-negative '(1 2 3 4 -5 6 7 -2 -1 0)) 2) -2)
```

### Задача 9
Напиште процедура, която добавя елемент в списък на даден индекс, използвайки `take` и `drop`.

```racket
(equal? (insert-at 1 0 '()) '(1))
(equal? (insert-at 1 0 '(2)) '(1 2))
(equal? (insert-at 10 1 '(1 2 3)) '(1 10 2 3))
```

### Задача 10
Напишете процедура, която конкатенира два списъка.

```racket
(equal? (concat '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6))
```

### Задача 11
Според Основната теорема на аритметиката всяко естествено число по-голямо от 1 може да бъде представено като произведение на прости числа. Напишете процедура, която връща сортиран в нарастващ ред списък на простите числа, чието произведение е равно на числото.

```racket
(equal? (factorise 2) '(2))
(equal? (factorise 6) '(2 3))
(equal? (factorise 13) '(13))
(equal? (factorise 123) '(3 41))
(equal? (factorise 152) '(2 2 2 19))
(equal? (factorise 12356498) '(2 7 11 19 41 103))
```

### Задача 12
Напишете процедура, която връща най-дългият подсписък (редица от **последвотални** елементи), която е сортирата в нарастащ ред.

```racket
(equal? (longest-ascending-sub '(1 0 5)) '(0 5))
(equal? (longest-ascending-sub '(1 5 2 3 1 5 6 7 7 1 5)) '(1 5 6 7 7))
(equal? (longest-ascending-sub '(1 5 2 3 1 5 2 7 7 15)) '(2 7 7 15))
(equal? (longest-ascending-sub '(1 5 2 3 4 5 6 7 7 1 5)) '(2 3 4 5 6 7 7))
(equal? (longest-ascending-sub '(1 5 2 4 6 8 3 4 1)) '(2 4 6 8))
```

### Задача 13
Реализирайте процедура `(get-sublist start-idx end-idx xs)`, която връща подсписък на `xs`, съдържащ елементите на индекси от `start-idx` и `end-idx`.

```racket
(equal? (get-sublist 2 6 '(1 2 2 3 1 5 6 7 7)) '(2 3 1 5 6))
```

### Задача 14
Реализирайте процедура `count-occurrences`, която брои колко пъти даден списък се съдържа в друг списък.

```racket
(= (count-occurrences '(1 5) '(1 5 2 3 1 5 6 7 7 1 5)) 3)
(= (count-occurrences '(5 5) '(5 5 5 3 1 5 6 7 5 5 5)) 4)
(= (count-occurrences '(6 6) '(2 2)) 0)
```

### Задача 15
Реализирайте процедура `ordered?`, която приема списък `xs` и връща ламбда, приемаща бинарен предикат `pred?` и проверява дали списъкът е сортиран според `pred?`.

```racket
(equal? ((ordered? '(1 2 3 5)) (λ (x y) (< x y))) #t)
(equal? ((ordered? '(1 8 29 92)) (λ (x y) (= y (+ (* x 3) 5)))) #t)
(equal? ((ordered? '(1 8 3 14)) (λ (x y) (= y (+ (* x 3) 5)))) #f)
```

### Задача 16
Реализирайте процедура `where`, която приема списък от числа и списък от унарни предикати и връща елементите на списъка, които удовлетворяват всички предикати.

```racket
(equal? (where '(3 4 5 6 7 8 9 10) (list even? (lambda (x) (> x 5)))) '(6 8 10))
(equal? (where '(3 4 5 7) (list even? (lambda (x) (> x 5)))) '())
(equal? (where '() (list odd? (λ (x) (> x 3)) (λ (x) (< x 20)))) '())
(equal? (where '(1 2 3 4 5 6 7 8 9 10 11 13 15) (list odd? (λ (x) (> x 3)) (λ (x) (< x 20)))) '(5 7 9 11 13 15))
```

### Задача 17
Реализирайте процедура `my-cartesian-product`, която приема две множества (списъци без повторения) и връща тяхното Декартово произведение.

> Забележка: Не използвайте вградената процедура `cartesian-product`

```racket
(equal? (my-cartesian-product '(1 2) '(3 4)) '((1 . 3) (1 . 4) (2 . 3) (2 . 4)))
(equal? (my-cartesian-product '(1 2 3 4 5) '(6 7 8)) '((1 . 6) (1 . 7) (1 . 8) (2 . 6) (2 . 7) (2 . 8) (3 . 6) (3 . 7) (3 . 8) (4 . 6) (4 . 7) (4 . 8) (5 . 6) (5 . 7) (5 . 8)))
```

### Задача 18
Дефинирайте процедура `my-flatten`, която приема списък от вложени списъци и връща списък само на едно ниво, съдържащ всички елементи на всички списъци.

```racket
(equal? (my-flatten '((1 2 3) (4 5 6) ((7 8) (9 10 (11 (12)))))) '(1 2 3 4 5 6 7 8 9 10 11 12))
```

### Задача 19
Дефинирайте процедура `shuffle`, която получава списък от `2*n` елемента във вида `x1 x2 ... xn y1 y2 ... yn` и връща списък от вида `x1 y1 x2 y2 ... xn yn`.

```racket
(equal? (shuffle '(2 5 1 3 4 7)) '(2 3 5 4 1 7))
(equal? (shuffle '(1 2 3 4 4 3 2 1)) '(1 4 2 3 3 2 4 1))
(equal? (shuffle '(1 1 2 2)) '(1 2 1 2))
```

### Задача 20
Дефинирайте процедура `tabulate`, която приема унарна процедура `f` и връща бинарна процедура на числата `a`и `b`. Резултатът от извикването `((tabulate f) a b)` трябва да бъде списък от точкови двойки във вида `(i . f(i))`, където `i` е в интервала `[a;b]`.

```racket
(equal? ((tabulate (λ (x) (* x x))) 1 5) '((1 . 1) (2 . 4) (3 . 9) (4 . 16) (5 . 25)))
```

### Задача 21
Дефинирайте процедура `deep-delete`, която премахва всички атоми, които са по-малки от тяхната дълбочина.

> Забележка: Дълбочина на един атом `x`в списък `xs` == колко пъти трябва да приложим `car` върху `xs`, за да достигнем `x`

```racket
(equal? (deep-delete '(1 (2 (2 4) 1) 0 (3 (1)))) '(1 (2 (4)) (3 ())))
```