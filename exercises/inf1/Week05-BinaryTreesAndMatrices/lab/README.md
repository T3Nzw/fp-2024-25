# Двоични дървета и матрици.

```racket
(define our-cool-tree '(1 (2 () ())
                          (3 (4 () ())
                             (5 () ()))))
```

### Задача 1
Реализирайте процедури, които връщат елементите на двоично дърво в списък:
 - `inorder`
 - `preorder`
 - `postorder`

```racket
(equal? (inorder our-cool-tree) '(2 1 4 3 5))
(equal? (preorder our-cool-tree) '(1 2 3 4 5))
(equal? (postorder our-cool-tree) '(2 4 5 3 1))
```

### Задача 2
Реализирайте процедурa, която намира броя на елементите в двоично дърво.

```racket
(= (size our-cool-tree) 5)
```

### Задача 3
Реализирайте процедурa, която намира височината на двоично дърво.

```racket
(= (height our-cool-tree) 3)
```

### Задача 4
Реализирайте процедура, която проверява дали едно двоично дърво е балансирано. Едно двоично дърво е балансирано, ако:
 - е празно
 - лявото му и дясното му поддърво са балансирани и разликата между
височините на лявото и дясното поддърво е 0 или 1

```racket
(equal? (balanced? our-cool-tree) #t)
```

### Задача 5
Реализирайте процедура, която проверява дали едно двоично дърво е перфектно балансирано. Едно двоично дърво е перфектно балансирано, ако:
 - е празно
 - лявото му и дясното му поддърво са перфектно балансирани и разликата между
броя елементи на лявото и дясното поддърво е 0 или 1

```racket
(equal? (perfectly-balanced? our-cool-tree) #f)
```

### Задача 6
Реализирайте процедури `min` и `max`, които приемат компаратор и двоично дърво и намират съответно най-малкия и най-големия елемент на дървото спрямо този компаратор.

```racket
(= (min < our-cool-tree) 1)
(= (max < our-cool-tree) 5)
```

### Задача 7
Реализирайте процедура, която връща всички листа на двоично дърво.

```racket
(equal? (leaves our-cool-tree) '(2 4 5))
```

### Задача 8
Реализирайте процедура, която връща елементите на ниво `n` в двоично дърво.

```racket
(equal? (at-level 0 our-cool-tree) '(1))
(equal? (at-level 1 our-cool-tree) '(2 3))
(equal? (at-level 2 our-cool-tree) '(4 5))
```

### Задача 9
Реализирайте процедура, която приема унарна функция `f` и я прилага върху всеки елемен на двоично дърво.

```racket
(equal? (map add1 our-cool-tree) '(2 (3 () ())
                                    (4 (5 () ())
                                        (6 () ()))))
```

### Задача 10
Реализирайте процедура, която приема унарен предикат `pred?` и връща списък с всички елементи на двоично дърво, които удовлетворяват условието.

```racket
(equal? (filter even? our-cool-tree) '(2 4))
```

### Задача 11
Реализирайте процедура `zero-rows`, която приема матрица `xss` и връща модифицирана версия на същата матрица, при която, ако даден ред на оригиналната матрица съдържа поне една `0`, то в модифицираната матрица целият ред ще се състои само от `0`.

```racket
(equal? (zero-rows '((1 2 0) 
                     (3 4 1) 
                     (0 5 7) 
                     (4 2 4))) '((0 0 0) 
                                 (3 4 1) 
                                 (0 0 0) 
                                 (4 2 4)))
```

### Задача 12
Реализирайте процедура `zero-cols`, която приема матрица `xss` и връща модифицирана версия на същата матрица, при която, ако дадена колона на оригиналната матрица съдържа поне една `0`, то в модифицираната матрица цялата колона ще се състои само от `0`.

```racket
(equal? (zero-cols '((1 2 0)
                     (3 4 1)
                     (0 5 7)
                     (4 2 4))) '((0 2 0)
                                 (0 4 0)
                                 (0 5 0)
                                 (0 2 0)))
```

### Задача 13
Да се дефинира процедура `diagonals`, която приема матрица и връща точкова двойка от вида `( <главен диагонал> . <второстепенен диагонал>)`.

```racket
(equal? (diagonals '((1 2 3) 
                     (4 5 6) 
                     (7 8 9))) '((1 5 9) . (3 5 7)))
(equal? (diagonals '((10 20) 
                     (30 40))) '((10 40) . (20 30)))
(equal? (diagonals '((1  2  3  4) 
                     (5  6  7  8) 
                     (9 10 11 12))) '((1 6 11) . (4 7 10)))
(equal? (diagonals '((100))) '((100) . (100)))
```

### Задача 14
Да се дефинира предикат `triangular?`, който получава квадратна числова матрица и проверява дали тя е горно триъгълна, т.е. дали всички елементи под главния ѝ диагонал са нули.

```racket
(equal? (triangular? '((1 2 3)
                       (0 5 6)
                       (0 0 9))) #t)

(equal? (triangular? '((0 2 3)
                       (0 0 6)
                       (1 0 0))) #f)

(equal? (triangular? '((1 2 3)
                       (1 5 6)
                       (0 0 9))) #f)

(equal? (triangular? '((1 2 3 4)
                       (0 5 6 7)
                       (0 0 8 9)
                       (0 0 0 9))) #t)
```

### Задача 15
Да се дефинира процедура `spiral`, която получава матрица и връща списък, съдържт елементите на матрицата, обходена спираловидно.

```racket
(equal? (spiral '((1 2 3) 
                  (8 9 4) 
                  (7 6 5))) '(1 2 3 4 5 6 7 8 9))
```