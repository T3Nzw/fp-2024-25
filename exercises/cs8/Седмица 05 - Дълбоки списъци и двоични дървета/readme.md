# Седмица 05 - Дълбоки списъци и двоични дървета

```scheme
(define dl '((1 2) ((3 (4) 5) (((6)))) (7)))

(define (atom? l)
  (and (not (null? l)) (not (pair? l))))
```

## Задача 00 - Брой атоми
Напишете функция `count-atoms`, която намира броя на атомите в дълбок списък.

## Задача 01 - Foldr за дълбоки списъци
Напишете функциите `deep-foldr`, който е еквивалентът на `foldr` за дълбоки списъци, с разликата, че приема и функция `term`, която се прилага над всеки от атомите.

### Пример:
```scheme
(deep-foldr + (lambda (x) x) 0 dl) ; -> 28
```

## Задача 02 - Map и Filter за дълбоки списъци
Напишете функциите `deep-map` и `deep-filter`, които са еквивалентите на `map` и `filter` за дълбоки списъци.

### Пример:
```scheme
(deep-map (lambda (x) (* x x)) dl) ; -> '((1 4) ((9 (16) 25) (((36)))) (49))
(deep-filter even? dl) ; -> '((2) (((4)) (((6)))))
```

## Задача 03 - Търсене в дълбок списък
Напишете функция `deep-member?`, която проверява дали елемент се съдържа в дълбок списък.

### Пример:
```scheme
(deep-member? 5 dl) ; -> #t
(deep-member? 10 dl) ; -> #f
```

## Задача 04 - Изглаждане на дълбок списък
Напишете функция `flatten`, която по подаден дълбок списък, връща списък от атомите в дълбокия списък.

### Пример:
```scheme
(flatten dl) ; -> '(1 2 3 4 5 6 7)
```

```scheme
(define (make-tree root left right) (list root left right))
(define (make-leaf root) (list root '() '()))
(define root car)
(define left cadr)
(define right caddr)
(define empty? null?)

(define t (make-tree 5
                     (make-tree 1
                                (make-tree 4
                                           '()
                                           (make-leaf 13))
                                (make-leaf 3))
                     (make-tree 8
                                (make-tree 0
                                           (make-leaf 10)
                                           (make-leaf 9))
                                (make-leaf 11))))
```

## Задача 05 - Височина на дърво
Напишете функция, която намира височина на двоично дърво.

### Пример:
```scheme
(height t) ; -> 4
```

## Задача 06 - Брой листа
Напишете функция, която намира броя на листата на двоично дърво.

### Пример:
```scheme
(count-leafs t) ; -> 5
```

## Задача 07 - Map за дървета
Напишете функция `map-tree`, която е еквивалентът на `map` за двоични дървета.

### Пример:
```scheme
(map-tree (lambda (x) (* x x)) t) ; -> '(25
                                         (1 (16 () (169 () ())) (9 () ()))
                                         (64 (0 (100 () ()) (81 () ())) (121 () ())))
```

## Задача 08 - Обхождане на дърво
Напишете функция, която обхожда двоично дърво по стратегията "ляво-корен-дясно", и връща списък от елементите на дървото в реда, в който са били посетени.

### Пример:
```scheme
(tree-to-list t) ; -> '(4 13 1 3 5 10 0 9 8 11)
```

## Задача 09 - Ниво на дърво
Напишете функция, която връща списък от елементите на двоично дърво, които са на едно и също ниво. Приемаме, че първото ниво е 0.

### Пример:
```scheme
(level 2 t) ; -> '(4 3 0 11)
```

## Задача 10 - Път до елемент
Напишете функция, която търси елемент в двоично дърво. Ако елементът бива намерен, функцията да връща пътя до елемента като списък от елементите, през които минава. В противен случай функцията да връща `#f`.

### Пример:
```scheme
(path-to 10 t) ; -> '(5 8 0 10)
```

## Задача 11 - Подрязване
Напишете функция, която премахва всички листа в двоично дърво.

### Пример:
```scheme
(prune t) ; -> '(5 (1 (4 () ()) ()) (8 (0 () ()) ()))
```

## Задача 12 - Дърво на извод
Напишете функция, която приема дърво, чиито листа са числа, а останалите възли - аритметични операции. Функцията да пресмята какъв би бил резултата от прилагането на операциите над техните поддървета.

### Пример:
```scheme
(define derivation-tree (make-tree +
                                   (make-tree -
                                              (make-tree +
                                                         (make-leaf 5)
                                                         (make-leaf 7))
                                              (make-leaf 3))
                                   (make-tree *
                                              (make-tree +
                                                         (make-tree /
                                                                    (make-leaf 20)
                                                                    (make-leaf 4))
                                                         (make-leaf 9))
                                              (make-leaf 6))))

(calculate derivation-tree) ; -> 93
```

## Задача 13 - Огледално дърво
Напишете функция, която проверява дали двоично дърво е огледално. Огледално дърво наричаме такова дърво, на което дясното поддърво има обратно симетрична структура спрямо лявото.

### Пример:
```scheme
;        4
;       / \         
;      1   6
;     /\   /\     
;    7  2 0  8
;    \      / 
;     10   11 

(define mirror (make-tree 4
                          (make-tree 1
                                     (make-tree 7
                                                '()
                                                (make-leaf 10))
                                     (make-leaf 2))
                          (make-tree 6
                                     (make-leaf 0)
                                     (make-tree 8
                                                (make-leaf 11)
                                                '()))))

(mirror? mirror) ; -> #t
(mirror? t) ; -> #f
```